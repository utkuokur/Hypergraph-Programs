#written by Dr. Joshua Cooper, Dr. Aaron Dutle, Dr. Gabrielle Tauscheck

def tensor_hyperdeterminant(T):
    
    #get the dimensions of the array
    
    n=len(T)
    current = deepcopy(T)
    k=0
    while type(current)==list:
        k+=1
        current= current[0]
    
    #get S (the monomials of total degree d) and initialize the matrix for the resultant,  
    
    d= n*(k-2)+1
    R = [] 
    for i in range(n):
        for j in range(d):
            R.append(i)
    
    L=Subsets(R, d, submultiset=True)
    S=[]
    for l in L:
        s=[]
        for i in range(n):
            s.append(l.count(i))
        S.append(deepcopy(s)) 
    row = []
    for r in S:
        row.append(0) 
    M = []
    for r in S:
        M.append(deepcopy(row))
    RED=[]      
    
    #for each monomial, determine the correct partial to multiply by, and determine if it is 'reduced'
    
    for r in range(len(S)):
        count=0
        ind=0 
        red=0
       
        
        while ind==0:
            while S[r][count] < k-1:
                count +=1
            ind = 1
        ind = deepcopy(count)    
        for i in range(d-k+2):
            red = red+S[r].count(k-1+i)
        
        #find the monomials that occur in the partial equation, change them by s, and put the entry into our matrix
        
        VAR=[]
        for i in range(n):
            for j in range(k-1):
                VAR.append(i)
        mons = Subsets(VAR, k-1, submultiset = True).list()
        for l in mons:
            expvec=deepcopy(S[r])
            expvec[ind]=expvec[ind]-k+1
            for m in l:
                expvec[m]+=1
            Tensentry = deepcopy(T[ind])
            for m in l:
                Tensentry = Tensentry[m]   
            if ind in l:
                number = l.count(ind)
                Tensentry = Tensentry * (number + 1)
            s=[]
            for i in range(n):
                if i == ind:
                    num = l.count(i)
                    s.append(num+1)
                else:
                    s.append(l.count(i)) 
            num_perm = 1
            choices = deepcopy(k)
            for elem in s:
                num_perm = num_perm * binomial(choices,elem)
                if elem != 0:
                    choices -= elem
            Tensentry = Tensentry * num_perm 
            M[r][S.index(expvec)] = Tensentry
        
        if red ==1:
            RED.append(r)
        else:
            red = 0
    RED.reverse()
    #return [Matrix(M).charpoly(), RED]                  
            
    #get the determinant of this matrix, get the reduced matrix, and return the hyperdeterminant
    
    P1=Matrix(M).charpoly()
    
    for j in range(len(RED)):
        del M[RED[j]] 
    for i in range(len(M)):
        for j in range(len(RED)):
            del M[i][RED[j]]
    P0=Matrix(M).charpoly()
    
    ratio = P1/P0
    return ratio.subs(x=0)*(-1)**(n*(k-1)**(n-1))

# ONLY WORKS FOR TREES!
# G = graph, S = list of vertices
# output = Steiner distance of S in G
def steiner_distance(G,S):
    final = False 
    Gc = copy(G)
    while not final:
        pendant = []
        count = 0
        for vertex in Gc.vertices():
            #print(vertex)
            if Gc.degree(vertex) == 1:
                pendant.append(vertex)
                if vertex not in S:
                    Gc.delete_vertex(vertex)
                else:
                    count += 1
        if count == len(pendant):
            final = True 
    return Gc.size()

def two_steiner_matrix_tree(H,verbose=False):
    n = H.order()
    if not H.is_tree():
        print('Graph must be a tree.')
        return False
    else:
        distance_matrix = [[0 for col in range(n)] for row in range(n)] 
        for x in range(n):
            for y in range(x,n):
                distance = steiner_distance(H,[x,y])/2
                distance_matrix[x][y] = distance
                distance_matrix[y][x] = distance
        if verbose:
            pretty_print(distance_matrix)
        return(distance_matrix)
    
def three_steiner_matrix_tree(H,verbose=False):
    n = H.order()
    if not H.is_tree():
        print('Graph must be a tree.')
        return False
    else:
        distance_matrix = [[[0 for col in range(n)] for row in range(n)] for x in range(n)]
        for x in range(n):
            for y in range(x,n):
                for z in range(y,n):
                    distance = steiner_distance(H,[x,y,z])/3
                    distance_matrix[x][y][z] = distance
                    distance_matrix[x][z][y] = distance
                    distance_matrix[y][x][z] = distance
                    distance_matrix[y][z][x] = distance
                    distance_matrix[z][x][y] = distance
                    distance_matrix[z][y][x] = distance
        if verbose:
            pretty_print(distance_matrix)
        return(distance_matrix)

def four_steiner_matrix_tree(H,verbose=False):
    n = H.order()
    if not H.is_tree():
        print('Graph must be a tree.')
        return False
    else:
        distance_matrix = [[[[0 for col in range(n)] for row in range(n)] for x in range(n)] for y in range(n)]
        for x in range(n):
            for y in range(n):
                for w in range(n):
                    for z in range(n):
                        distance_matrix[x][y][w][z] = steiner_distance(H,[x,y,w,z])/4
        if verbose:
            pretty_print(distance_matrix)
        return(distance_matrix)
    
def five_steiner_matrix_tree(H,verbose=False):
    n = H.order()
    if not H.is_tree():
        print('Graph must be a tree.')
        return False
    else:
        distance_matrix = [[[[[0 for col in range(n)] for row in range(n)] for x in range(n)] for y in range(n)] for z in range(n)]
        for x in range(n):
            for y in range(n):
                for w in range(n):
                    for z in range(n):
                        for l in range(n):
                            distance_matrix[x][y][w][z][l] = steiner_distance(H,[x,y,w,z,l])/5
        if verbose:
            pretty_print(distance_matrix)
        return(distance_matrix)
    
def six_steiner_matrix_tree(H,verbose=False):
    n = H.order()
    if not H.is_tree():
        print('Graph must be a tree.')
        return False
    else:
        distance_matrix = [[[[[[0 for col in range(n)] for row in range(n)] for x in range(n)] for y in range(n)] for z in range(n)] for w in range(n)]
        for x in range(n):
            for y in range(n):
                for w in range(n):
                    for z in range(n):
                        for l in range(n):
                            for m in range(n):
                                distance_matrix[x][y][w][z][l][m] = steiner_distance(H,[x,y,w,z,l,m])/6
        if verbose:
            pretty_print(distance_matrix)
        return(distance_matrix)
    
def seven_steiner_matrix_tree(H,verbose=False):
    n = H.order()
    if not H.is_tree():
        print('Graph must be a tree.')
        return False
    else:
        distance_matrix = [[[[[[[0 for col in range(n)] for row in range(n)] for x in range(n)] for y in range(n)] for z in range(n)] for w in range(n)] for m in range(n)]
        for x in range(n):
            for y in range(n):
                for w in range(n):
                    for z in range(n):
                        for l in range(n):
                            for m in range(n):
                                for p in range(n):
                                    distance_matrix[x][y][w][z][l][m][p] = steiner_distance(H,[x,y,w,z,l,m,p])/7
        if verbose:
            pretty_print(distance_matrix)
        return(distance_matrix)
    
def eight_steiner_matrix_tree(H,verbose=False):
    n = H.order()
    if not H.is_tree():
        print('Graph must be a tree.')
        return False
    else:
        distance_matrix = [[[[[[[[0 for col in range(n)] for row in range(n)] for x in range(n)] for y in range(n)] for z in range(n)] for w in range(n)] for m in range(n)] for p in range(n)]
        for x in range(n):
            for y in range(n):
                for w in range(n):
                    for z in range(n):
                        for l in range(n):
                            for m in range(n):
                                for p in range(n):
                                    for q in range(n):
                                        distance_matrix[x][y][w][z][l][m][p][q] = steiner_distance(H,[x,y,w,z,l,m,p,q])/8
        if verbose:
            pretty_print(distance_matrix)
        return(distance_matrix)

def nine_steiner_matrix_tree(H,verbose=False):
    n = H.order()
    if not H.is_tree():
        print('Graph must be a tree.')
        return False
    else:
        distance_matrix = [[[[[[[[[0 for col in range(n)] for row in range(n)] for x in range(n)] for y in range(n)] for z in range(n)] for w in range(n)] for m in range(n)] for p in range(n)] for q in range(n)]
        for x in range(n):
            for y in range(n):
                for w in range(n):
                    for z in range(n):
                        for l in range(n):
                            for m in range(n):
                                for p in range(n):
                                    for q in range(n):
                                        for j in range(n):
                                            final = False
                                            G = copy(H)
                                            while not final:
                                                pendant = []
                                                for vertex in G.vertices():
                                                    if G.degree(vertex) == 1:
                                                        pendant.append(vertex) 
                                                        if vertex != x and vertex != y and vertex != w and vertex != z and vertex != l and vertex != m and vertex != p and vertex != q and vertex != j:
                                                            neighbor = G.neighbors(vertex)
                                                            G.delete_edge(vertex, neighbor[0])
                                                count = 0
                                                for element in pendant:
                                                    if element == x or element == y or element == w or element == z or element == l or element == m or element == p or element == q or element == j:
                                                        count += 1
                                                if count == len(pendant):
                                                    final = True 
                                            steiner_distance = G.size()
                                            distance_matrix[x][y][w][z][l][m][p][q][j] = steiner_distance/9
        if verbose:
            pretty_print(distance_matrix)
        return(distance_matrix)
